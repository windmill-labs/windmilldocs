# Job debouncing

Job debouncing prevents redundant job executions by canceling or coalescing multiple triggers that occur within a specified time window. This feature helps optimize resource usage and prevents unnecessary duplicate computations.

Job debouncing is a [Cloud plans and Pro Enterprise Self-Hosted](/pricing) only feature.

## How debouncing works

When debouncing is enabled, Windmill cancels pending jobs with identical tags or arguments when new jobs with the same characteristics are submitted within the debounce window. Only the most recent job execution proceeds, effectively "debouncing" rapid successive triggers.

Debouncing operates globally across the workspace and works with both scripts and flows. The key parameters are:

## Time window in seconds

The debounce window defines the period during which duplicate jobs are canceled. When a new job arrives within this window with matching characteristics, any pending jobs are canceled in favor of the new one.

## Custom debounce key

Optional parameter to define custom debounce grouping. You can use workspace-specific keys using the variable `$workspace` or argument values using `$args[name_of_arg]`. This allows fine-grained control over which jobs are considered duplicates.

## Debouncing in Scripts & Flows

### Script debouncing

Script debouncing can be configured from the [Settings](../../script_editor/settings.mdx) menu. Navigate to "Runtime" and then "Debouncing" to define the debounce time window and optionally a custom debounce key.

When enabled, multiple rapid invocations of the same script will result in only the latest execution running, with previous pending executions being canceled.

### Flow debouncing

From the Flow Settings Advanced menu, select "Debouncing" to configure the debounce time window and optionally a custom debounce key.

This is particularly useful for flows triggered by webhooks or events that may fire multiple times in quick succession.

### Debouncing for scripts within flows

Individual steps within a flow can have their own debounce settings. This can be configured in the `Advanced` menu of each step, under the "Runtime" tab in the "Debouncing" section.

This allows you to prevent redundant executions of specific steps that might be triggered multiple times as a flow executes.

## Dependency jobs

For dependency jobs, debouncing is enabled by default. This prevents redundant dependency computations when multiple jobs require the same dependencies, improving overall system efficiency.

## Use cases

Common scenarios where debouncing is beneficial:

- **Webhook endpoints**: Preventing duplicate processing when webhooks are triggered multiple times
- **File watchers**: Avoiding redundant processing when files are rapidly modified
- **User-triggered actions**: Preventing accidental double submissions
- **Dependency resolution**: Automatically enabled to optimize dependency job execution
- **Event stream processing**: Coalescing rapid event sequences into single executions

## Monitoring debounced jobs

Jobs that have been debounced (canceled due to a newer job) will be marked accordingly in the [Runs menu](../5_monitor_past_and_future_runs/index.mdx). You can filter and track debounced jobs using the debounce key to understand the debouncing behavior in your workspace.

## Best practices

- Set appropriate debounce windows based on your use case - too short may not catch duplicates, too long may delay legitimate executions
- Use custom debounce keys when you need fine-grained control over which jobs are considered duplicates
- Monitor debounced jobs regularly to ensure the feature is working as intended
- Consider the interaction between debouncing and concurrency limits when both are configured

## Comparison with concurrency limits

While [concurrency limits](../21_concurrency_limits/index.md) control the maximum number of simultaneous executions, debouncing prevents redundant job submissions from being queued in the first place. These features can be used together for comprehensive job execution control:

- **Concurrency limits**: Controls how many jobs run simultaneously
- **Debouncing**: Prevents duplicate jobs from being queued

Both features help optimize resource usage but serve different purposes in job execution management.