# GCP Pub/Sub triggers

Windmill can connect to [**Google Cloud Pub/Sub**](https://cloud.google.com/pubsub/docs/overview) and trigger runnables (scripts, flows) when messages are published on topics.\
You can configure Windmill to either **pull** messages from subscriptions or **receive pushed** messages via auto-generated endpoints.

Google Cloud Pub/Sub triggers is a [self-hosted Enterprise](/pricing) feature.

---

## How to use

### Configure GCP connection

- Select an existing [GCP resource](https://hub.windmill.dev/resource_types/154/gcloud) (service account credentials) or create a new one.

> The service account used must have enough permissions for Windmill to fully manage Pub/Sub resources. Specifically:
>
> - **Pub/Sub Viewer** (`roles/pubsub.viewer`): to check if topics or subscriptions exist, list them.
> - **Pub/Sub Subscriber** (`roles/pubsub.subscriber`): to attach to subscriptions and consume messages.
> - **Pub/Sub Editor** (`roles/pubsub.editor`): needed to create or update subscriptions, and to optionally delete the subscription in the cloud when deleting the associated trigger if the user chooses to do so.
>
> If you prefer not to assign these three individually, you can simply grant the **Pub/Sub Admin** role (`roles/pubsub.admin`).
>
> Additionally, if you want to create **authenticated push delivery subscriptions**, the service account must also have **Service Account User** (`roles/iam.serviceAccountUser`) permission. See [Authenticate Push Subscriptions](https://cloud.google.com/pubsub/docs/authenticate-push-subscriptions) for more details.

### Subscription setup

#### Select topic and subscription

- **Choose a topic** from your GCP project. You can refresh the list if needed.
- Decide how to set up your subscription:
  - **Create or update a subscription**: Windmill will create a new subscription or update an existing one.
  - **Use an existing subscription**: Link an existing subscription from your GCP project.

##### When creating/updating a subscription:

- Specify a **Subscription ID**, or leave it empty to auto-generate one.
- Choose the **delivery type**:
  - **Pull**: Windmill sets the subscription as a **Pull** subscription.
  - **Push**: Windmill sets the subscription as a **Push** subscription.
    - For **push delivery**, Windmill sets the subscription's push endpoint URL to match the path of the trigger.\
      The format is:\
      `{base_endpoint}/api/gcp/w/{workspace_id}/{trigger_path}`
    - Example: if the trigger path is `u/test/fabulous_trigger`, the endpoint will be:\
      `{base_endpoint}/api/gcp/w/myworkspace/u/test/fabulous_trigger`
    - When creating or updating a **push** subscription, Windmill allows you to configure:
      - Whether **authentication** is enabled or disabled.

Refer to [Google Cloud Pub/Sub - Managing Subscriptions](https://cloud.google.com/pubsub/docs/subscriber) for more details about delivery types.

##### When using an existing subscription:

- Select an existing subscription ID **among the subscriptions fetched from the selected topic**.
- Windmill will automatically detect the subscription's **delivery type** based on the cloud configuration.
- If the subscription is of **push delivery** type:
  - The subscription's endpoint URL must match the path of the trigger that will be bound to it.
  - The expected format is:\
    `{base_endpoint}/api/gcp/w/{workspace_id}/{trigger_path}`
> **Note:** You must not have multiple subscriptions pointing to the same trigger URL (for example, two subscriptions targeting `{base_endpoint}/api/gcp/w/myworkspace/u/test/fabulous_trigger`).

### Choose the runnable

- Select the **script** or **flow** to trigger when Pub/Sub messages are received.

### Message acknowledgment control

GCP Pub/Sub triggers provide two modes for handling message acknowledgments. This setting is configurable from the UI in the advanced section under the Settings tab.

#### Automatic acknowledgment (default)
- Windmill automatically acknowledges or negatively acknowledges messages based on execution results
- If the script/flow succeeds: message is acknowledged (`ack`)  
- If the script/flow fails: message is negatively acknowledged (`nack`) - the message will be redelivered immediately or through exponential backoff depending on the [Google Cloud Pub/Sub retry policy](https://cloud.google.com/pubsub/docs/handling-failures) you configured
- No manual intervention required

#### Manual acknowledgment  
- The user receives the message `ack_id` and must manually acknowledge messages
- **Note**: `ack_id` is only available for pull delivery type subscriptions. If you do not acknowledge messages, they will be redelivered through your retry logic and the same message will be processed again by Windmill
- **Message deadline**: 600 seconds (maximum allowed by GCP, set by Windmill)
- If you forget to acknowledge the message after the 600-second deadline, the message will be redelivered immediately or through exponential backoff depending on the [Google Cloud Pub/Sub retry policy](https://cloud.google.com/pubsub/docs/handling-failures) you configured
- If you manually nack the message, the message will be redelivered immediately or through exponential backoff depending on the [Google Cloud Pub/Sub retry policy](https://cloud.google.com/pubsub/docs/handling-failures) you configured
---

## Implementation examples

Below are examples for handling GCP Pub/Sub messages in Windmill.

> Windmill provides the Pub/Sub message as the argument `payload` (a base64-encoded string) to your runnable.

### Basic script

```typescript
export async function main(payload: string) {
  const decoded = new TextDecoder().decode(Uint8Array.from(atob(payload), c => c.charCodeAt(0)));

  try {
    const jsonData = JSON.parse(decoded);
    console.log("Received JSON data:", jsonData);
    // Process structured data
  } catch (e) {
    console.log("Received plain text:", decoded);
    // Process raw text
  }

  return { processed: true };
}
```

---

### Using a preprocessor

If you configure a [preprocessor](../43_preprocessors/index.mdx), you can extract fields before they reach the main function.

> Windmill provides the Pub/Sub message as the argument `payload` (a base64-encoded string) to the preprocessor.

#### GCP Pub/Sub trigger object

- `subscription`: Subscription ID
- `topic`: Topic ID
- `message_id`: Unique message ID
- `publish_time`: Publish timestamp (RFC 3339 format with `Z`, e.g., `"2024-04-07T12:34:56Z"`)
- `attributes`: Key-value metadata
- `delivery_type`: `"push"` or `"pull"` (the type of delivery)
- `ordering_key`: Ordering key (optional, if message ordering is enabled)
- `headers`: HTTP headers for push delivery (only present for push)
- `ack_id?`: Acknowledgment ID for manual message acknowledgment (string, only available for pull delivery type)

Example preprocessor:

```typescript
export async function preprocessor(
  event: {
    kind: 'gcp',
    payload: string, // base64 encoded payload
    message_id: string,
    subscription: string,
    ordering_key?: string,
    attributes?: Record<string, string>,
    delivery_type: "push" | "pull",
    headers?: Record<string, string>,
    publish_time?: string,
    ack_id?: string, // acknowledgment ID for manual acknowledgment (only for pull delivery)
  }
) {
  if (event.kind === 'gcp') {
    const decodedString = atob(event.payload);

    const attributes = event.attributes || {};
    const contentType = attributes['content-type'] || attributes['Content-Type'];
    const isJson = contentType === 'application/json';

    let parsedMessage: any = decodedString;
    if (isJson) {
      try {
        parsedMessage = JSON.parse(decodedString);
      } catch (err) {
        throw new Error(`Invalid JSON payload: ${err}`);
      }
    }

    return {
      messageAsDecodedString: decodedString,
      contentType,
      parsedMessage,
      attributes,
      ack_id: event.ack_id
    };
  }

  throw new Error(`Expected gcp trigger kind got: ${event.kind}`);
}
```

Then your `main` function can simply receive the extracted arguments:

```typescript
export async function main(
  messageAsDecodedString: string,
  contentType?: string,
  parsedMessage?: any,
  attributes?: Record<string, string>,
  ack_id?: string,
) {
  console.log("Decoded String:", messageAsDecodedString);
  console.log("Content-Type:", contentType);
  console.log("Parsed Message:", parsedMessage);
  console.log("Attributes:", attributes);
  console.log("Ack ID:", ack_id);
}
```

### Manual acknowledgment example

When **Auto acknowledge messages** is set to `false`, you can manually control message acknowledgment using the `ack_id`. This is useful for complex business logic where acknowledgment depends on external factors.

```typescript
export async function main(payload: string, delivery_type: "push" | "pull", ack_id?: string) {
  const decoded = new TextDecoder().decode(Uint8Array.from(atob(payload), c => c.charCodeAt(0)));
  
  try {
    const jsonData = JSON.parse(decoded);
    
    // Process the message
    const result = await processMessage(jsonData);
    
    // Only handle manual acknowledgment for pull delivery with ack_id
    if (delivery_type === "pull" && ack_id) {
      if (result.success) {
        // Manually acknowledge the message
        await acknowledgeMessage(ack_id, true); // ack
        return { processed: true, acknowledged: true };
      } else {
        // Manually negative acknowledge the message  
        await acknowledgeMessage(ack_id, false); // nack
        return { processed: false, acknowledged: false };
      }
    }
    
    // For push delivery or when ack_id is not available
    return { processed: result.success, delivery_type };
  } catch (error) {
    console.error("Processing failed:", error);
    // Negative acknowledge on error (only for pull with ack_id)
    if (delivery_type === "pull" && ack_id) {
      await acknowledgeMessage(ack_id, false); // nack
    }
    throw error;
  }
}

async function processMessage(data: any) {
  // Your business logic here
  return { success: true };
}

async function acknowledgeMessage(ackId: string, success: boolean) {
  // Use GCP client library or REST API to acknowledge the message
  // This is a placeholder - implement based on your preferred method
  console.log(`${success ? 'Acknowledging' : 'Nack-ing'} message with ack_id: ${ackId}`);
}
```

> **Note**: When using manual acknowledgment, you have 600 seconds (10 minutes) to acknowledge each message. GCP will redeliver messages according to your subscription's retry policy (immediate redelivery or exponential backoff) if the deadline is exceeded or if you manually `nack` them. Unacknowledged messages will be processed again by Windmill, so always ensure your script acknowledges messages within the deadline window.

---

## Troubleshooting

- **Permission issues**: Verify the service account has required Pub/Sub permissions. If the correct permissions are set but you still encounter `unauthorized` or `permission denied` errors, it might indicate that Google has updated required permissions. Please contact Windmill support so we can investigate and assist.
- **Push delivery failures**: If using existing subscription ensure the push endpoint URL matches the required format (`{base_endpoint}/api/gcp/w/{workspace_id}/{trigger_path}`) and is unique across the workspace.
- **Topic or subscription not found**: Refresh the list to fetch the latest available resources.
- **Message redelivery behavior**: Message redelivery is controlled entirely by your GCP subscription's retry policy settings. Messages will be redelivered by GCP if:
  - **Automatic acknowledgment**: Script fails (Windmill nacks the message)
  - **Manual acknowledgment**: Deadline exceeded (600 seconds) or manual nack
  The redelivery timing (immediate vs exponential backoff) depends on your subscription's retry policy configuration in GCP, not Windmill settings. For more details, see [Google Cloud Pub/Sub handling failures](https://cloud.google.com/pubsub/docs/handling-failures).

---
